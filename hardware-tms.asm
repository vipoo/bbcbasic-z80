include "hbios.inc"
include "constants.inc"

DATREG		EQU	$BE	; default port
CMDREG		EQU	$BF	; default port

NAME_START 	EQU	$3800
NAME_START_LOW	EQU	NAME_START & $FF
NAME_START_HIGH	EQU	(NAME_START / $100) | $40
NAME_LEN	EQU	$300

COLR_START	EQU	$2000
COLR_START_LOW	EQU	COLR_START & $FF
COLR_START_HIGH	EQU	(COLR_START / $100) | $40
COLR_LEN	EQU	$1800

PATN_START	EQU	$0000
PATN_START_LOW	EQU	PATN_START & $FF
PATN_START_HIGH	EQU	(PATN_START / $100) | $40
PATN_LEN	EQU	$1800

COL_TRANSPARENT		EQU	0
COL_BLACK		EQU	1
COL_MEDGREEN		EQU	2
COL_LIGGREEN		EQU	3
COL_DRKBLUE		EQU	4
COL_LIGBLUE		EQU	5
COL_DRKRED		EQU	6
COL_CYAN		EQU	7
COL_MEDRED		EQU	8
COL_LIGRED		EQU	9
COL_DRKYELLOW		EQU	10
COL_LIGYELLOW		EQU	11
COL_DRKGREEN		EQU	12
COL_MAGENTA		EQU	13
COL_GREY		EQU	14
COL_WHITE		EQU	15

OPC_INC_A	EQU	$3C
OPC_DEC_A	EQU	$3D

; 0 128 Black (normal background)
; 1 129 Red
; 2 130 Green
; 3 131 Yellow
; 4 132 Blue
; 5 133 Magenta (blue/red)
; 6 134 Cyan (blue/green)
; 7 135 White (normal foreground)
; 8 136 Flashing black/white
; 9 137 Flashing red/cyan
; 10 138 Flashing green/magenta
; 11 139 Flashing yellow/blue
; 12 140 Flashing blue/yellow
; 13 141 Flashing magenta/green
; 14 142 Flashing cyan/red
; 15 143 Flashing white/black

	PUBLIC	MODE, GCOL, CLG, PLOT, DRAW, MOVE

	EXTERN	XEQ, EXPRI, ERROR, COMMA, EXPRN, EXTERR, INT, IDIV, SFLOAT, SWAP, FSUB, ABS

	EXTERN	MATH_POS_HL, MATH_NEG_HL, MATH_CP_HL_DE, DIV_HL_C

; 21 TSTATES
#define		TMS_IODELAY	PUSH AF !
				POP AF

MODE:	CALL	EXPRI		; get mode
	EXX
	LD	A, L
	CP	2
	JP	NZ, MODEERR
CLG:
MODE2:
	DI
	CALL	INITMODE
	CALL	INITNAMETBL
	CALL	INITCOLRTBL
	CALL	INITPATNTBL
	EI
	JP	XEQ

MODEERR:
	LD	A, 31 ; ARGUMENT ERROR
	JP	ERROR

;
; GCOL [<numeric>,]<numeric>
; GCOL colour
; GCOL mode,colour
GCOL:	CALL	EXPRI		; MODE OR COLOUR
	EXX

	LD	A, (IY)
	CP	','
	JR	NZ, GCOL1	; COLOUR ONLY
	INC	IY

	POP	HL		; HL CONTAINS MODE - IGNORED FOR MOMENT
	CALL	EXPRI		; COLOUR
	EXX

	; COLOUR VALUE IN HL
GCOL1:	BIT	7, L
	JR	NZ, GCOL2	; SET BACKGROUND COLOUR

	LD	A, (TMS_COLOUR)
	AND	$0F		; MASK OFF CURRENT FOREGROUND COLOUR
	LD	B, A

	LD	A, L		; SHIFT UP TO HIGH NIBBLE
	ADD	A, A
	ADD	A, A
	ADD	A, A
	ADD	A, A
	OR	B		; MIXIN NEW COLOUR VALUE
	LD	(TMS_COLOUR), A
	JP	XEQ

GCOL2:
	LD	A, (TMS_COLOUR)
	AND	$F0
	LD	B, A
	LD	A, L
	RES	7, A
	LD	(TMS_COLOUR), A
	JP	XEQ

; PLOT Mode,X,Y
; PLOT <numeric>,<numeric>,<numeric>
; PLOT <numeric>,<numeric>
; PLOT BY <numeric>,<numeric>
; Only support by X, Y (alias for 69, X, Y)
; x - 0 to 1279, y 0 to 1023
; mode 2 raw dimensions are 256 by 192
; x = x / 5 and y = y / 5
PLOT:
	CALL	EXPPTX		; X VALUE
	PUSH	HL

	CALL	COMMA
	CALL	EXPPTY		; Y VALUE

	POP	DE

	CALL	CALC_ADDRX
	CALL	CALC_ADDRY
	CALL	CALC_VALUE
	LD	B, A
	CALL	CALC_ADDR
	CALL	TMS_ORWRITE
	JP	XEQ

; MOVE <numeric>,<numeric>
MOVE:
	CALL	EXPPTX
	LD	(GCURX), HL	; STORE RAW PIXEL X VALUE

	CALL	COMMA
	CALL	EXPPTY
	LD	(GCURY), HL	; STORE RAW PIXEL Y VALUE
	JP	XEQ


; DRAW <numeric>,<numeric>
; Implement line draw using Bresenham algorithm
; https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm
DRAW:
	CALL	EXPPTX
	LD	(GDRAWX), HL

	CALL	COMMA
	CALL	EXPPTY		; "Y"
	LD	(GDRAWY), HL

; dx% = ABS(x1%-x0%)
; IF x0% < x1% THEN sx% = 1 ELSE sx% = -1
	LD	HL, (GDRAWX)
	LD	DE, (GCURX)
	OR	A
	SBC	HL, DE

	BIT	7, H
	JR	Z, DRAW1	; GDRAWX > GCURX -> X1% > X0%

	CALL	MATH_POS_HL
	JR	DRAW2

DRAW1:
	LD	A, OPC_INC_A	; SX = 1
	JR	DRAW3

DRAW2:
	LD	A, OPC_DEC_A	; SX = -1

DRAW3:
	LD	(SX), A
	LD	(DX), HL

	LD	HL, (GDRAWX)
	LD	DE, (GCURX)

	CALL	CALC_ADDRX
	CALL	CALC_VALUE
	LD	(GVALUE), A

; dy% = -ABS(y1%-y0%)
; IF y0%<y1% THEN sy% = 1 ELSE sy% = -1

	LD	HL, (GCURY)
	CALL	CALC_ADDRY

	LD	HL, (GDRAWY)
	LD	DE, (GCURY)

	OR	A
	SBC	HL, DE

	BIT	7, H
	JR	NZ, DRAW10	; Y0% > Y1%

	CALL	MATH_NEG_HL
	JR	DRAW11

DRAW10:
	LD	A, OPC_DEC_A
	JR	DRAW12

DRAW11:
	LD	A, OPC_INC_A

DRAW12:
	LD	(SY), A
	LD	(DY), HL

; err% = dx%+dy%
	LD	HL, (DX)
	LD	DE, (DY)
	ADD	HL, DE
	LD	(ERR), HL

DRAWLOOP:
	CALL	CALC_ADDR

	LD	B, 0
GVALUE:	EQU	$-1
	CALL	TMS_ORWRITE

; IF (x0% = x1% AND y0% = y1%) GOTO 5130
	LD	HL, (GCURX)
	LD	DE, (GDRAWX)
	OR	A
	SBC	HL, DE
	JP	NZ, DRAW20

	LD	HL, (GCURY)
	LD	DE, (GDRAWY)
	OR	A
	SBC	HL, DE
	JR	Z, DRAW99

DRAW20:
; e2% = 2*err%
	LD	HL, 0
ERR:	EQU	$-2

	ADD	HL, HL
	LD	(ERR2), HL

; IF (e2% >= dy%) THEN err% = err% + dy% : x0% = x0% + sx%
	LD	DE, 0 ;(DY)
DY:	EQU	$-2

	CALL	MATH_CP_HL_DE
	JP	C, DRAW21

	LD	HL, (ERR)
	LD	DE, (DY)
	ADD	HL, DE
	LD	(ERR), HL

	LD	A, (GCURX)
	INC	A		; SELF MODIFIED CODE DEC A OR INC A
SX:	EQU	$-1
	LD	(GCURX), A

	LD	E, A
	LD	D, 0
	CALL	CALC_ADDRX
	CALL	CALC_VALUE
	LD	(GVALUE), A

DRAW21:

; IF (e2% <= dx%) THEN err% = err% + dx% : y0% = y0% + sy%
	LD	HL, (DX)
	LD	DE, 0
ERR2:	EQU	$-2
	CALL	MATH_CP_HL_DE
	JR	C, DRAWLOOP

	LD	DE, 0; (DX)
DX:	EQU	$-2

	LD	HL, (ERR)
	ADD	HL, DE
	LD	(ERR), HL

	LD	A, (GCURY)
	INC	A		; SELF MODIFIED CODE DEC A OR INC A
SY:	EQU	$-1
	LD	(GCURY), A

	ld	l, a
	CALL	CALC_ADDRY

	JP	DRAWLOOP
DRAW99:
	JP	XEQ

INITMODE:
	LD	HL, MODE2REGS
	LD	B, 8
	LD	C, $7F			;(0 | $80) - 1
	LD	A, (TMS_COLOUR)		; SET TEXT COLOUR/G COLOUR BACK
	LD	(M2R_COL), A

INITMODE1:
	LD	A, (HL)
	OUT	(CMDREG), A
	TMS_IODELAY
	INC	HL
	INC	C
	LD	A, C
	OUT	(CMDREG), A
	TMS_IODELAY
	DJNZ	INITMODE1
	RET

INITNAMETBL:
	LD	L, NAME_START_LOW
	LD	H, NAME_START_HIGH
	CALL	TMS_WRADDR
	TMS_IODELAY

	LD	DE, NAME_LEN
	LD	B, 0
	LD	C, DATREG
INITNAMETBL1:
	OUT	(C), B
	TMS_IODELAY
	INC	B
	DEC	DE
	LD	A, E
	OR	D
	JR	NZ, INITNAMETBL1
	RET

INITCOLRTBL:
	LD	H, COLR_START_HIGH
	LD	L, COLR_START_LOW
	CALL	TMS_WRADDR
	TMS_IODELAY

	LD	DE, COLR_LEN
	LD	A, (TMS_COLOUR)
	LD	B, A
	LD	C, DATREG
INITCOLRTBL1:
	OUT	(C), B
	TMS_IODELAY
	DEC	DE
	LD	A, E
	OR	D
	JR	NZ, INITCOLRTBL1
	RET

INITPATNTBL:
	LD	H, PATN_START_HIGH
	LD	L, PATN_START_LOW
	CALL	TMS_WRADDR
	TMS_IODELAY

	LD	DE, PATN_LEN
	LD	B, $0
	LD	C, DATREG
INITPATNTBL1:
	OUT	(C), B
	TMS_IODELAY
	DEC	DE
	LD	A, E
	OR	D
	JR	NZ, INITPATNTBL1
	RET

; EVALUATE NUMBER TO AN XSCALED RANGE (0 TO 255)
; NUMBER / (1280/256)
; RETURNS IN HL
EXPPTX:
	CALL	EXPRI		;"X"
	EXX
	LD	C, 5		; DIVIDE X BY 5 (FAST)
	CALL	DIV_HL_C
	RET

;EVALUATE NUMBER TO A YSCALED RANGE (191 TO 0)
; 191 - (NUMBER / (1024/192))
; RETURNS IN HL
EXPPTY:
	CALL	EXPRN		; "Y"
	CALL	SFLOAT

	LD	DE, $2AAA	;LD	DED'E'B, 5.33333
	EXX
	LD	DE, $AAA9
	EXX
	LD	B, $82

	CALL	IDIV		; DIVIDE Y BY 5.3333333
	CALL	SWAP

	LD	HL, $3F80	; 191 - Y + .5
	EXX
	LD	HL, 0000
	EXX
	LD	C, $87

	CALL	SFLOAT
	CALL	FSUB
	CALL	ABS
	CALL	INT
	EXX
	RET


; value% = 2^(7-(x0% MOD 8))
CALC_VALUE:	; DE HAS X
	LD	A, E
	AND	$07

	LD	B, A
	INC	B
	LD	A, $00
	SCF
CALC_VALUE1:
	RRA
	DJNZ	CALC_VALUE1
	RET

CALC_ADDRX:
	LD	A, E		; L => X AND $F8
	AND	$F8
	LD	(ADDRX), A
	RET

CALC_ADDRY:
	LD	A, L		; A = Y MOD 8
	AND	$07

	SRL	L		; E = (Y / 8) * 256
	SRL	L
	SRL	L
	LD	H, L
	LD	L, 0

	LD	C, A
	LD	B, 0
	ADD	HL, BC		; BYTE ADDRESS = L + DE + A
	LD	(ADDRY), HL
	RET

; X IN DE, Y IN HL
; RETURN ADDR IN HL
CALC_ADDR:
	LD	DE, 0
ADDRX:	EQU	$ - 2
	LD	HL, 0
ADDRY:	EQU	$ - 2
	ADD	HL, DE
	RET

; OR IN THE VALUE OF B FOR ADDR HL
TMS_ORWRITE:
	; value precalulated in B
	; ADDR IN HL

	DI
	CALL	TMS_RDADDR
	TMS_IODELAY
	TMS_IODELAY
	IN	A, (DATREG)
	LD	C, A
	TMS_IODELAY
	CALL	TMS_WRADDR
	TMS_IODELAY
	TMS_IODELAY
	LD	A, C
	OR	B
	OUT	(DATREG), A
	EI
	RET

TMS_WRADDR:
	LD	A, L
	OUT	(CMDREG), A
	LD	A, H
	OR	$40
	OUT	(CMDREG), A
	RET

TMS_RDADDR:
	LD	A, L
	OUT	(CMDREG), A
	LD	A, H
	OUT	(CMDREG), A
	RET

MODE2REGS:
	DEFB	$02
	DEFB	$C2 | 32
	DEFB	$0E
	DEFB	$FF
	DEFB	$03
	DEFB	$76
	DEFB	$03
M2R_COL:
	DEFB	$0E

TMS_COLOUR:
	DEFB	COL_WHITE * 16 + COL_BLACK	; HIGH NIBBLE IS FORCOLOUR, LOW NIBBLE IS BACKCOLOUR

GCURX:	DEFW	0
GCURY:	DEFW	0
GDRAWX:	DEFW	0
GDRAWY:	DEFW	0
